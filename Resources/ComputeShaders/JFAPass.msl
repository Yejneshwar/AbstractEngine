#include <metal_stdlib>
using namespace metal;

// The custom 'distance_squared' function has been REMOVED.
// The shader will now use the efficient, built-in version provided by Metal.

kernel void jfa_pass(
    texture2d<float, access::read>  inTexture  [[texture(0)]],
    texture2d<float, access::write> outTexture [[texture(1)]],
    constant int&                   step       [[buffer(0)]],
    uint2                           gid        [[thread_position_in_grid]])
{
    if (gid.x >= outTexture.get_width() || gid.y >= outTexture.get_height()) {
        return;
    }

    float2 closest_seed_pos = inTexture.read(gid).xy;
    float min_dist_sq = -1.0f;

    if (closest_seed_pos.x >= 0.0f) {
        // This now calls the standard Metal library function.
        min_dist_sq = distance_squared(float2(gid), closest_seed_pos);
    }

    for (int j = -1; j <= 1; ++j) {
        for (int i = -1; i <= 1; ++i) {
            int2 sample_pos = int2(gid) + int2(i, j) * step;
            
            // FIXED: Cast texture dimensions to 'int' to safely compare with 'sample_pos'.
            if (sample_pos.x >= 0 && sample_pos.y >= 0 &&
                sample_pos.x < (int)inTexture.get_width() && sample_pos.y < (int)inTexture.get_height())
            {
                float2 neighbor_seed_pos = inTexture.read(uint2(sample_pos)).xy;

                if (neighbor_seed_pos.x >= 0.0f) {
                    // This also calls the standard Metal library function.
                    float dist_sq = distance_squared(float2(gid), neighbor_seed_pos);

                    if (min_dist_sq < 0.0f || dist_sq < min_dist_sq) {
                        min_dist_sq = dist_sq;
                        closest_seed_pos = neighbor_seed_pos;
                    }
                }
            }
        }
    }

    outTexture.write(float4(closest_seed_pos, 0.0, 1.0), gid);
}